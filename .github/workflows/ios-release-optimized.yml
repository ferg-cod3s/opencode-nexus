name: iOS TestFlight Release (Optimized)

on:
  push:
    tags:
      - 'ios-v*'
    branches:
      - 'main'
      - 'test-ios-build'
      - 'release'
  workflow_dispatch:
    inputs:
      upload_to_testflight:
        description: 'Upload to TestFlight'
        required: false
        default: true
        type: boolean
      tag_name:
        description: 'Release tag name'
        required: false
        type: string

jobs:
  build-ios:
    name: iOS TestFlight Build
    runs-on: self-hosted
    timeout-minutes: 90

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Display Cost Warning
        if: needs.detect-runner.outputs.cost_warning != ''
        uses: ./.github/actions/display-cost-warning
        with:
          cost_warning: ${{ needs.detect-runner.outputs.cost_warning }}
          repository: ${{ github.repository }}

      - name: Validate Runner Environment
        uses: ./.github/actions/validate-runner
        with:
          runner_type: self-hosted

      - name: Set up environment variables
        run: |
          TAG_NAME="${{ github.event.inputs.tag_name || github.ref_name }}"
          VERSION_NUMBER=$(echo "$TAG_NAME" | sed 's/^[^0-9]*//;s/-.*$//')
          BUILD_NUMBER=$(git rev-list --count HEAD)

          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV
          echo "VERSION_NUMBER=$VERSION_NUMBER" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

          echo "Version: $VERSION_NUMBER (Build: $BUILD_NUMBER)"
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '15.4'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Install Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup caching
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.bun/install/cache
            frontend/node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/Cargo.lock', '**/bun.lockb', 'src-tauri/Cargo.toml', 'frontend/package.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-
            ${{ runner.os }}-

      - name: Cache Rust target
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: ${{ runner.os }}-rust-target-${{ hashFiles('**/Cargo.lock', 'src-tauri/src/**/*.rs') }}
          restore-keys: |
            ${{ runner.os }}-rust-target-

      - name: Install frontend dependencies
        run: |
          cd frontend
          bun install --frozen-lockfile

      - name: Build frontend (production)
        run: |
          cd frontend
          bun run build
        env:
          NODE_ENV: production

      - name: Install Tauri CLI
        run: |
          cargo install tauri-cli --version "^2" --locked

      - name: Pre-build Rust library for iOS
        id: prebuild
        run: |
          echo "::group::Pre-building Rust library for iOS"
          START_TIME=$(date +%s)
          
          cd src-tauri
          echo "Building Rust code for iOS (aarch64-apple-ios)..."
          
          # Build with correct library name from Cargo.toml
          RUST_BACKTRACE=0 cargo build --target aarch64-apple-ios --release --lib
          
          RUST_BUILD_TIME=$(($(date +%s) - START_TIME))
          echo "::notice::Rust build completed in ${RUST_BUILD_TIME}s"
          
          # Verify library was built
          LIB_NAME="libsrc_tauri_lib.a"
          RUST_LIB_PATH="target/aarch64-apple-ios/release/$LIB_NAME"
          
          if [ ! -f "$RUST_LIB_PATH" ]; then
            echo "âŒ ERROR: Expected library not found at $RUST_LIB_PATH"
            echo "Available files:"
            find target/aarch64-apple-ios/release -name "*.a" -type f
            exit 1
          fi
          
          echo "âœ… Rust library built successfully: $LIB_NAME"
          echo "::endgroup::"
        env:
          RUST_LOG: warn

      - name: Setup iOS Xcode project
        run: |
          cd src-tauri
          
          # Initialize the iOS project (creates gen/apple/)
          echo "ðŸ”§ Initializing iOS project..."
          cargo tauri ios init
          
          # Create the Externals directory structure
          echo "ðŸ“ Creating directory structure..."
          mkdir -p gen/apple/Externals/arm64/Release
          mkdir -p gen/apple/Externals/arm64/release
          
          # Copy the pre-built library to where Xcode expects it
          echo "ðŸ“¦ Copying pre-built library..."
          LIB_NAME="libsrc_tauri_lib.a"
          RUST_LIB_PATH="target/aarch64-apple-ios/release/$LIB_NAME"
          
          cp "$RUST_LIB_PATH" gen/apple/Externals/arm64/Release/libapp.a
          cp "$RUST_LIB_PATH" gen/apple/Externals/arm64/release/libapp.a
          echo "âœ… Copied $LIB_NAME to gen/apple/Externals/arm64/"
          
          # Verify the copies
          ls -la gen/apple/Externals/arm64/Release/
          ls -la gen/apple/Externals/arm64/release/
          
          # Copy ExportOptions.plist
          if [ -f "ios-config/ExportOptions.plist" ]; then
            cp ios-config/ExportOptions.plist gen/apple/ExportOptions.plist
            echo "âœ… ExportOptions.plist copied"
          fi
          
          # =====================================================
          # Patch the Xcode project for CI compatibility
          # Use simple sed replacement that maintains valid pbxproj syntax
          # =====================================================
          echo "ðŸ”§ Patching Xcode project for CI compatibility..."
          cd gen/apple
          PBXPROJ="src-tauri.xcodeproj/project.pbxproj"
          
          # Backup original
          cp "$PBXPROJ" "$PBXPROJ.backup"
          
          # Simple single-line patch: prepend an exit check to the existing cargo command
          # This keeps the script on one line and maintains valid pbxproj syntax
          # The pattern: shellScript = "cargo tauri ios xcode-script..."
          # Becomes:     shellScript = "if [ -f \"${SRCROOT}/Externals/arm64/${CONFIGURATION}/libapp.a\" ]; then echo CI-Skip; exit 0; fi; cargo tauri ios xcode-script..."
          sed -i.bak 's|shellScript = "cargo tauri ios xcode-script|shellScript = "if [ -f \\"${SRCROOT}/Externals/arm64/${CONFIGURATION}/libapp.a\\" ]; then echo CI-Skip; exit 0; fi; cargo tauri ios xcode-script|' "$PBXPROJ"
          
          # Validate the patch was applied
          if grep -q 'CI-Skip' "$PBXPROJ"; then
            echo "âœ… Xcode project patched successfully"
          else
            echo "âš ï¸ Patch may not have been applied, checking original pattern..."
            if grep -q 'cargo tauri ios xcode-script' "$PBXPROJ"; then
              echo "âŒ Original pattern still exists - patch failed"
              # Restore backup and continue (build phase will just run longer)
              cp "$PBXPROJ.backup" "$PBXPROJ"
            else
              echo "âš ï¸ Script pattern not found - Tauri may have changed format"
            fi
          fi
          
          rm -f "$PBXPROJ.bak" "$PBXPROJ.backup"
          
          echo "âœ… iOS Xcode project setup complete (CocoaPods-free)"

      - name: Validate pre-build setup
        run: |
          cd src-tauri
          
          echo "ðŸ” Validating pre-build setup..."
          
          # Check library exists
          LIB_PATH="gen/apple/Externals/arm64/Release/libapp.a"
          if [ ! -f "$LIB_PATH" ]; then
            echo "âŒ ERROR: Pre-built library not found at $LIB_PATH"
            exit 1
          fi
          
          # Validate library format
          if ! file "$LIB_PATH" | grep -q "ar archive"; then
            echo "âŒ ERROR: Library is not a valid ar archive"
            exit 1
          fi
          
          # Validate architecture
          if ! lipo -info "$LIB_PATH" 2>/dev/null | grep -q "arm64"; then
            echo "âŒ ERROR: Library not built for arm64"
            exit 1
          fi
          
          # Check Xcode project was patched (look for the CI-Skip marker)
          if ! grep -q "CI-Skip" gen/apple/src-tauri.xcodeproj/project.pbxproj; then
            echo "âš ï¸ WARNING: Xcode project patch marker not found"
            echo "Build phase may run the full Rust build (slower but still works)"
          else
            echo "âœ… Xcode project patched for CI skip"
          fi
          
          # Check Xcode project exists
          if [ ! -f "gen/apple/src-tauri.xcodeproj/project.pbxproj" ]; then
            echo "âŒ ERROR: Xcode project not found"
            exit 1
          fi
          
          echo "âœ… All validations passed"

      - name: Setup code signing
        env:
          IOS_CERTIFICATE_P12: ${{ secrets.IOS_CERTIFICATE_P12 }}
          IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD_TEMP || secrets.IOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD_TEMP || secrets.IOS_CERTIFICATE_PASSWORD }}
        run: |
          # Validate required secrets are present
          if [ -z "$IOS_CERTIFICATE_P12" ]; then
            echo "âŒ ERROR: IOS_CERTIFICATE_P12 secret is not configured"
            echo "Please configure the following secrets in GitHub repository settings:"
            echo "- IOS_CERTIFICATE_P12 (base64 encoded .p12 certificate)"
            echo "- IOS_CERTIFICATE_PASSWORD"
            echo "- KEYCHAIN_PASSWORD"
            echo "- IOS_PROVISIONING_PROFILE"
            echo "- APP_STORE_CONNECT_API_KEY_ID"
            echo "- APP_STORE_CONNECT_ISSUER_ID"
            echo "- APP_STORE_CONNECT_API_PRIVATE_KEY"
            exit 1
          fi

          KEYCHAIN_PATH=$(mktemp -d)/build.keychain

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          echo "$IOS_CERTIFICATE_P12" | base64 --decode > /tmp/cert.p12

          # Validate certificate file was created and is not empty
          if [ ! -s /tmp/cert.p12 ]; then
            echo "âŒ ERROR: Certificate file is empty or invalid"
            echo "Check that IOS_CERTIFICATE_P12 secret contains valid base64 data"
            exit 1
          fi

          security import /tmp/cert.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$IOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/xcodebuild

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          rm -f /tmp/cert.p12

          echo "âœ… Keychain configured for code signing"

      - name: Install provisioning profile
        env:
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles/

          echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > /tmp/profile.mobileprovision

          cp /tmp/profile.mobileprovision \
            ~/Library/MobileDevice/Provisioning\ Profiles/OpenCodeNexus_AppStore.mobileprovision

          rm -f /tmp/profile.mobileprovision

          echo "âœ… Provisioning profile installed"

      - name: Archive iOS app (Direct xcodebuild)
        run: |
          cd src-tauri/gen/apple

          mkdir -p build/archives

          echo "ðŸ—ï¸ Starting iOS archive with direct xcodebuild..."
          
          # Archive directly with xcodebuild - the Build Rust Code phase will skip
          # since we already have libapp.a in place
          xcodebuild \
            -project src-tauri.xcodeproj \
            -scheme src-tauri_iOS \
            -configuration Release \
            -archivePath build/archives/OpenCodeNexus.xcarchive \
            -derivedDataPath build/DerivedData \
            archive \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            DEVELOPMENT_TEAM="PCJU8QD9FN" \
            OTHER_CODE_SIGN_FLAGS="--timestamp=none" \
            -verbose

          echo "âœ… App archived successfully"

      - name: Export IPA for App Store
        id: export
        run: |
          cd src-tauri/gen/apple

          mkdir -p build/ipa

          echo "ðŸ“¦ Exporting IPA..."
          xcodebuild \
            -exportArchive \
            -archivePath build/archives/OpenCodeNexus.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath build/ipa \
            -allowProvisioningUpdates

          IPA_FILE=$(find build/ipa -name "*.ipa" -type f)
          if [ -z "$IPA_FILE" ]; then
            echo "âŒ IPA file not found!"
            exit 1
          fi

          IPA_SIZE=$(du -h "$IPA_FILE" | cut -f1)
          echo "âœ… IPA exported: $IPA_FILE ($IPA_SIZE)"
          echo "IPA_FILE=$IPA_FILE" >> $GITHUB_ENV

          # Set output for next job
          echo "ipa-path=$IPA_FILE" >> $GITHUB_OUTPUT

      - name: Normalize IPA for TestFlight
        run: |
          set -e
          echo "ðŸ”§ Normalizing IPA for TestFlight..."

          IPA_FILE="${{ env.IPA_FILE }}"
          WORK_DIR="$(pwd)"

          rm -rf build/ipa_work temp_app Payload
          mkdir -p build/ipa_work

          cd build/ipa_work
          cp "$WORK_DIR/$IPA_FILE" app.ipa
          unzip -q app.ipa -d temp_app

          if [ ! -d "temp_app/Payload" ]; then
            echo "âŒ Payload directory not found in IPA"
            exit 1
          fi

          APP_DIR=$(find temp_app/Payload -maxdepth 1 -type d -name "*.app" | head -n 1)
          if [ -z "$APP_DIR" ]; then
            echo "âŒ App bundle not found in Payload"
            exit 1
          fi

          echo "ðŸ“± App bundle: $APP_DIR"

          # Update Info.plist version
          INFO_PLIST="$APP_DIR/Info.plist"
          /usr/libexec/PlistBuddy -c "Set CFBundleShortVersionString $VERSION_NUMBER" "$INFO_PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Set CFBundleVersion $BUILD_NUMBER" "$INFO_PLIST" 2>/dev/null || true

          # Remove forbidden static library if present
          if [ -f "$APP_DIR/libapp.a" ]; then
            echo "ðŸ—‘ï¸ Removing forbidden static library libapp.a from app bundle"
            rm -f "$APP_DIR/libapp.a"
          fi

          # Re-embed provisioning profile
          PROFILE_PATH="${HOME}/Library/MobileDevice/Provisioning Profiles/OpenCodeNexus_AppStore.mobileprovision"
          if [ -f "$PROFILE_PATH" ]; then
            cp "$PROFILE_PATH" "$APP_DIR/embedded.mobileprovision"
          fi

          # Create distribution entitlements
          rm -f distribution_entitlements.plist
          plutil -create xml1 distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :application-identifier string PCJU8QD9FN.com.agentic-codeflow.opencode-nexus" distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :com.apple.developer.team-identifier string PCJU8QD9FN" distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :get-task-allow bool false" distribution_entitlements.plist

          # Re-sign app
          codesign --force \
            --sign "Apple Distribution: John Ferguson (PCJU8QD9FN)" \
            --entitlements distribution_entitlements.plist \
            "$APP_DIR"

          # Re-pack IPA
          cd temp_app
          rm -f "$WORK_DIR/$IPA_FILE"
          zip -qr "$WORK_DIR/$IPA_FILE" Payload

          cd "$WORK_DIR"

          echo "âœ… Normalized IPA ready: $IPA_FILE"

      - name: Upload to TestFlight
        if: github.event.inputs.upload_to_testflight != 'false' && (github.event_name != 'workflow_dispatch' || github.event.inputs.upload_to_testflight == 'true')
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
        run: |
          TEMP_KEY_DIR=$(mktemp -d)

          echo "$APP_STORE_CONNECT_API_PRIVATE_KEY" | base64 --decode > "$TEMP_KEY_DIR/AuthKey.p8"

          IPA_FILE="${{ env.IPA_FILE }}"

          echo "ðŸ“¤ Uploading to TestFlight..."
          xcrun altool \
            --upload-app \
            --type ios \
            --file "$IPA_FILE" \
            --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
            --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
            --apiKeysDir "$TEMP_KEY_DIR" \
            --verbose

          rm -rf "$TEMP_KEY_DIR"

          echo "âœ… IPA uploaded to TestFlight"

      - name: Create GitHub Release
        if: github.ref_type == 'tag'
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.IPA_FILE }}
          tag_name: ${{ env.TAG_NAME }}
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(env.TAG_NAME, 'beta') || contains(env.TAG_NAME, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload IPA to artifacts
        if: always() && env.IPA_FILE != ''
        uses: actions/upload-artifact@v4
        with:
          name: opencode-nexus-ios-${{ env.VERSION_NUMBER }}-build-${{ env.BUILD_NUMBER }}
          path: ${{ env.IPA_FILE }}
          retention-days: 30

      - name: Build success summary
        if: success()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ðŸŽ‰ iOS Build Successful

          ### âœ… Completed Steps
          1. **Pre-build Phase**: Rust library built separately
          2. **Project Setup**: Xcode project patched for CI compatibility
          3. **Archive Phase**: Direct xcodebuild archive (no TCP socket issues)
          4. **Export**: IPA successfully exported and normalized
          5. **Deployment**: Uploaded to TestFlight and GitHub Release

          ### ðŸ“± Next Steps
          1. Check [App Store Connect](https://appstoreconnect.apple.com/apps) for processing status
          2. Monitor TestFlight for build availability (5-15 minutes)
          3. Invite internal testers to test the build

          ### ðŸ”§ Build Details
          - **Runner**: macOS 14 (Apple Silicon)
          - **Xcode**: 15.4
          - **Rust Target**: aarch64-apple-ios
          - **Library**: libsrc_tauri_lib.a â†’ libapp.a
          - **Export Method**: App Store
          - **Build Time**: Optimized with pre-build strategy

          ### ðŸš€ Improvements Made
          - âœ… Eliminated TCP socket connection errors
          - âœ… Reduced build time by pre-building Rust library
          - âœ… Enhanced error handling and validation
          - âœ… Improved reliability with direct xcodebuild

          Release workflow completed successfully!
          EOF

      - name: Build failure analysis
        if: failure()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## âŒ iOS Build Failed

          ### ðŸ” Troubleshooting Checklist
          1. **Library Build**: Check if `libsrc_tauri_lib.a` was built successfully
          2. **Library Copy**: Verify library was copied to `gen/apple/Externals/arm64/Release/libapp.a`
          3. **Xcode Patch**: Ensure project.pbxproj was patched correctly
          4. **Code Signing**: Verify certificate and provisioning profile are current
          5. **Dependencies**: Check Rust toolchain and Xcode compatibility

          ### ðŸ› ï¸ Common Issues & Solutions
          - **Library not found**: Check Cargo.toml name matches scripts
          - **Code signing errors**: Verify certificate and provisioning profile validity
          - **Xcode build failures**: Check iOS SDK and target compatibility
          - **TestFlight upload fails**: Verify API key permissions and IPA format

          ### ðŸ“Š Debug Information
          - **Rust Version**: $(rustc --version)
          - **Tauri CLI**: $(cargo tauri --version 2>/dev/null || echo "Not found")
          - **Xcode Version**: $(xcodebuild -version | head -1)
          - **iOS SDK**: $(xcrun --sdk iphoneos --show-sdk-version)

          Check the job logs above for specific error details.
          EOF