name: iOS TestFlight Release

on:
  push:
    tags:
      - 'ios-v*'
    branches:
      - 'main'
      - 'test-ios-build'
      - 'test-ios-build-fix'
      - 'release'

jobs:
  build-ios:
    runs-on: macos-14
    timeout-minutes: 90

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up environment variables
        run: |
          TAG_NAME="${{ github.event.inputs.tag_name || github.ref_name }}"
          VERSION_NUMBER=$(echo "$TAG_NAME" | sed 's/^[^0-9]*//;s/-.*$//')
          BUILD_NUMBER=$(git rev-list --count HEAD)

          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV
          echo "VERSION_NUMBER=$VERSION_NUMBER" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

          echo "Version: $VERSION_NUMBER (Build: $BUILD_NUMBER)"

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '15.4'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-ios

      - name: Install Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup caching
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.bun/install/cache
            frontend/node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/Cargo.lock', '**/bun.lockb', 'src-tauri/Cargo.toml', 'frontend/package.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-
            ${{ runner.os }}-

      - name: Cache Rust target
        uses: actions/cache@v4
        with:
          path: src-tauri/target
          key: ${{ runner.os }}-rust-target-${{ hashFiles('**/Cargo.lock', 'src-tauri/src/**/*.rs') }}
          restore-keys: |
            ${{ runner.os }}-rust-target-

      - name: Install frontend dependencies
        run: |
          cd frontend
          bun install --frozen-lockfile

      - name: Build frontend (production)
        run: |
          cd frontend
          bun run build
        env:
          NODE_ENV: production

      - name: Install Tauri CLI
        run: |
          cargo install tauri-cli --version "^2" --locked

      - name: Pre-warm Rust dependencies
        run: |
          cd src-tauri
          echo "Pre-warming Rust dependencies..."
          cargo fetch --target aarch64-apple-ios
          echo "Dependencies pre-warmed"

      - name: Pre-build Rust library for iOS
        run: |
          echo "::group::Building Rust library for iOS"
          START_TIME=$(date +%s)
          
          cd src-tauri
          echo "Building Rust code for iOS (aarch64-apple-ios)..."
          RUST_BACKTRACE=0 cargo build --target aarch64-apple-ios --release
          
          RUST_BUILD_TIME=$(($(date +%s) - START_TIME))
          echo "::notice::Rust build completed in ${RUST_BUILD_TIME}s"
          echo "Rust library built successfully"
          echo "::endgroup::"
        env:
          RUST_LOG: warn

      - name: Setup iOS Xcode project
        run: |
          cd src-tauri
          
          # Initialize the iOS project (creates gen/apple/)
          cargo tauri ios init
          
          # Create the Externals directory structure for pre-built library
          # Xcode uses different case for configuration names
          mkdir -p gen/apple/Externals/arm64/Release
          mkdir -p gen/apple/Externals/arm64/release
          
          # Copy pre-built library to where Xcode expects it
          # The actual library name is libsrc_tauri_lib.a based on Cargo.toml
          RUST_LIB_PATH="target/aarch64-apple-ios/release/libsrc_tauri_lib.a"
          if [ -f "$RUST_LIB_PATH" ]; then
            cp "$RUST_LIB_PATH" gen/apple/Externals/arm64/Release/libapp.a
            cp "$RUST_LIB_PATH" gen/apple/Externals/arm64/release/libapp.a
            echo "Copied pre-built libsrc_tauri_lib.a to gen/apple/Externals/arm64/"
            ls -la gen/apple/Externals/arm64/Release/
          else
            # Fallback: search for any .a file
            FOUND_LIB=$(find target/aarch64-apple-ios/release -name "lib*.a" -type f | head -1)
            if [ -n "$FOUND_LIB" ] && [ -f "$FOUND_LIB" ]; then
              cp "$FOUND_LIB" gen/apple/Externals/arm64/Release/libapp.a
              cp "$FOUND_LIB" gen/apple/Externals/arm64/release/libapp.a
              echo "Copied pre-built $(basename $FOUND_LIB) to gen/apple/Externals/arm64/"
              ls -la gen/apple/Externals/arm64/Release/
            else
              echo "ERROR: No static library found in target/aarch64-apple-ios/release/"
              echo "Available files:"
              ls -la target/aarch64-apple-ios/release/ 2>/dev/null || echo "Directory not found"
              exit 1
            fi
          fi
          
          # Modify the Xcode project to skip Rust build phase when libapp.a exists
          # This is the critical fix - use a separate Python script file
          cat > /tmp/patch_pbxproj.py << 'PYEOF'
          import re
          import sys
          
          pbxproj_path = sys.argv[1]
          
          with open(pbxproj_path, "r") as f:
              content = f.read()
          
          # Find the shellScript line for "Build Rust Code" phase and replace it
          old_pattern = r'(shellScript = ")cargo tauri ios xcode-script[^"]*(")'
          
          # CI-compatible script that checks for pre-built library first
          new_script = '''\\1# CI-Compatible: Skip if pre-built libapp.a exists
          OUTPUT_DIR="${SRCROOT}/Externals/arm64/${CONFIGURATION}"
          LIBAPP_PATH="${OUTPUT_DIR}/libapp.a"
          if [ -f "$LIBAPP_PATH" ]; then
            echo "Pre-built libapp.a found at $LIBAPP_PATH - skipping Rust build"
            exit 0
          fi
          echo "libapp.a not found, running Tauri build..."
          cargo tauri ios xcode-script -v --platform ${PLATFORM_DISPLAY_NAME:?} --sdk-root ${SDKROOT:?} --framework-search-paths "${FRAMEWORK_SEARCH_PATHS:?}" --header-search-paths "${HEADER_SEARCH_PATHS:?}" --gcc-preprocessor-definitions "${GCC_PREPROCESSOR_DEFINITIONS:-}" --configuration ${CONFIGURATION:?} ${FORCE_COLOR} ${ARCHS:?}\\2'''
          
          content = re.sub(old_pattern, new_script, content)
          
          with open(pbxproj_path, "w") as f:
              f.write(content)
          
          print("Updated project.pbxproj with CI-compatible build script")
          PYEOF
          
          python3 /tmp/patch_pbxproj.py gen/apple/src-tauri.xcodeproj/project.pbxproj
          
          # Copy ExportOptions.plist
          cp ios-config/ExportOptions.plist gen/apple/ExportOptions.plist
          
          # Setup CocoaPods
          cd gen/apple
          sed -i.bak '/target.*macOS/,/^end$/d' Podfile 2>/dev/null || true
          sed -i.bak '/MACOSX_DEPLOYMENT_TARGET/d' Podfile 2>/dev/null || true
          rm -f Podfile.bak
          
          pod install --repo-update || pod install
          
          echo "iOS Xcode project setup complete"

      - name: Setup code signing
        env:
          IOS_CERTIFICATE_P12: ${{ secrets.IOS_CERTIFICATE_P12 }}
          IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD || secrets.IOS_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$(mktemp -d)/build.keychain

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          echo "$IOS_CERTIFICATE_P12" | base64 --decode > /tmp/cert.p12

          security import /tmp/cert.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$IOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/xcodebuild

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          rm -f /tmp/cert.p12

          echo "Keychain configured for code signing"

      - name: Install provisioning profile
        env:
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles/

          echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > /tmp/profile.mobileprovision

          cp /tmp/profile.mobileprovision \
            ~/Library/MobileDevice/Provisioning\ Profiles/OpenCodeNexus_AppStore.mobileprovision

          rm -f /tmp/profile.mobileprovision

          echo "Provisioning profile installed"

      - name: Archive iOS app
        run: |
          cd src-tauri/gen/apple

          # Verify workspace exists
          if [ ! -f "src-tauri.xcworkspace/contents.xcworkspacedata" ]; then
            echo "Error: Xcode workspace not found"
            echo "Available files:"
            ls -la
            exit 1
          fi

          mkdir -p build/archives

          # Archive directly with xcodebuild - the Build Rust Code phase will skip
          # since we already have libapp.a in place
          xcodebuild \
            -workspace src-tauri.xcworkspace \
            -scheme src-tauri_iOS \
            -configuration Release \
            -archivePath build/archives/OpenCodeNexus.xcarchive \
            -derivedDataPath build/DerivedData \
            archive \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            DEVELOPMENT_TEAM="PCJU8QD9FN" \
            OTHER_CODE_SIGN_FLAGS="--timestamp=none"

          echo "App archived successfully"

      - name: Export IPA for App Store
        id: export
        run: |
          cd src-tauri/gen/apple

          mkdir -p build/ipa

          xcodebuild \
            -exportArchive \
            -archivePath build/archives/OpenCodeNexus.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath build/ipa \
            -allowProvisioningUpdates

          IPA_FILE=$(find build/ipa -name "*.ipa" -type f)
          if [ -z "$IPA_FILE" ]; then
            echo "IPA file not found!"
            exit 1
          fi

          IPA_SIZE=$(du -h "$IPA_FILE" | cut -f1)
          echo "IPA exported: $IPA_FILE ($IPA_SIZE)"
          echo "IPA_FILE=$IPA_FILE" >> $GITHUB_ENV

          # Set output for next job
          echo "ipa-path=$IPA_FILE" >> $GITHUB_OUTPUT

      - name: Normalize IPA for TestFlight
        run: |
          set -e
          echo "Normalizing IPA for TestFlight..."

          IPA_FILE="${{ env.IPA_FILE }}"
          WORK_DIR="$(pwd)"

          rm -rf build/ipa_work temp_app Payload
          mkdir -p build/ipa_work

          cd build/ipa_work
          cp "$WORK_DIR/$IPA_FILE" app.ipa
          unzip -q app.ipa -d temp_app

          if [ ! -d "temp_app/Payload" ]; then
            echo "Payload directory not found in IPA"
            exit 1
          fi

          APP_DIR=$(find temp_app/Payload -maxdepth 1 -type d -name "*.app" | head -n 1)
          if [ -z "$APP_DIR" ]; then
            echo "App bundle not found in Payload"
            exit 1
          fi

          echo "App bundle: $APP_DIR"

          # Update Info.plist version to match tag-derived VERSION_NUMBER
          INFO_PLIST="$APP_DIR/Info.plist"
          /usr/libexec/PlistBuddy -c "Set CFBundleShortVersionString $VERSION_NUMBER" "$INFO_PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Set CFBundleVersion $BUILD_NUMBER" "$INFO_PLIST" 2>/dev/null || true

          # Remove forbidden static library if present
          if [ -f "$APP_DIR/libapp.a" ]; then
            echo "Removing forbidden static library libapp.a from app bundle"
            rm -f "$APP_DIR/libapp.a"
          fi

          # Re-embed provisioning profile from secrets-based file if present
          PROFILE_PATH="${HOME}/Library/MobileDevice/Provisioning Profiles/OpenCodeNexus_AppStore.mobileprovision"
          if [ -f "$PROFILE_PATH" ]; then
            cp "$PROFILE_PATH" "$APP_DIR/embedded.mobileprovision"
          fi

          # Create minimal distribution entitlements plist
          rm -f distribution_entitlements.plist
          plutil -create xml1 distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :application-identifier string PCJU8QD9FN.com.agentic-codeflow.opencode-nexus" distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :com.apple.developer.team-identifier string PCJU8QD9FN" distribution_entitlements.plist
          /usr/libexec/PlistBuddy -c "Add :get-task-allow bool false" distribution_entitlements.plist

          # Re-sign app with distribution certificate
          codesign --force \
            --sign "Apple Distribution: John Ferguson (PCJU8QD9FN)" \
            --entitlements distribution_entitlements.plist \
            "$APP_DIR"

          # Re-pack IPA with correct Payload structure
          cd temp_app
          rm -f "$WORK_DIR/$IPA_FILE"
          zip -qr "$WORK_DIR/$IPA_FILE" Payload

          cd "$WORK_DIR"

          echo "Normalized IPA ready: $IPA_FILE"

      - name: Upload to TestFlight
        if: github.event.inputs.upload_to_testflight != 'false' && (github.event_name != 'workflow_dispatch' || github.event.inputs.upload_to_testflight == 'true')
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
        run: |
          TEMP_KEY_DIR=$(mktemp -d)

          echo "$APP_STORE_CONNECT_API_PRIVATE_KEY" | base64 --decode > "$TEMP_KEY_DIR/AuthKey.p8"

          IPA_FILE="${{ env.IPA_FILE }}"

          xcrun altool \
            --upload-app \
            --type ios \
            --file "$IPA_FILE" \
            --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
            --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
            --apiKeysDir "$TEMP_KEY_DIR" \
            --verbose

          rm -rf "$TEMP_KEY_DIR"

          echo "IPA uploaded to TestFlight"

      - name: Create GitHub Release
        if: github.ref_type == 'tag'
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.IPA_FILE }}
          tag_name: ${{ env.TAG_NAME }}
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(env.TAG_NAME, 'beta') || contains(env.TAG_NAME, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload IPA to artifacts
        if: always() && env.IPA_FILE != ''
        uses: actions/upload-artifact@v4
        with:
          name: opencode-nexus-ios-${{ env.VERSION_NUMBER }}-build-${{ env.BUILD_NUMBER }}
          path: ${{ env.IPA_FILE }}
          retention-days: 30

      - name: Build summary
        if: success()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## iOS Build Successful

          ### Next Steps
          1. Check [App Store Connect](https://appstoreconnect.apple.com/apps) for processing status
          2. Monitor TestFlight for build availability (5-15 minutes)
          3. Invite internal testers to test the build

          ### Build Details
          - Runner: macOS 14 (Apple Silicon)
          - Xcode: 15.4
          - Rust Target: aarch64-apple-ios
          - Export Method: App Store
          - Symbols Uploaded: Yes

          Release workflow completed successfully!
          EOF

      - name: Build failure summary
        if: failure()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## iOS Build Failed

          ### Troubleshooting
          1. Check job logs above for error details
          2. Verify all secrets are configured correctly
          3. Ensure provisioning profile is not expired
          4. Check App Store Connect API key is valid

          ### Common Issues
          - Code signing errors: Verify certificate and provisioning profile are current
          - Build failures: Check Rust compilation and Xcode compatibility
          - TestFlight upload fails: Verify API key permissions and IPA format
          EOF
